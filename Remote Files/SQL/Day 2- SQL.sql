
										--> REVISION QUESTIONS FROM DAY 1 --<
--> QUESTION 1
--> EMPLOYEE ID, EMPLOYEE NAME IN UPPER CASE, EMAIL IN LOWER CASE, JOB ID WITH _ REPLACED WITH -,
--> SALARY, ANNUAL SALARY, COMMISSION PCT-->NULL-->NC,
--> MANAGER ID, DEPARTMENT ID, 
--> TAX--> IF ANNNUAL SALARY < 25000, 10% TAX, IF BETWEEN 25000 AND 50000, 20% TAX, ELSE 30% TAX
--> HIRE DATE, HIRE DAY--> MON
--> THESE DETAILS OF EMPLOYEES WORKING IN DEP 50,80
--> OR HIRED IN YEAR 1997 OR 1998
--> SORTED BY DEPARTMENT ID AND SALARY DESC
SELECT EMPLOYEE_ID, UPPER(CONCAT(FIRST_NAME,' ', LAST_NAME)) AS EMP_NAME, 
	   LOWER(EMAIL) AS EMAIL, REPLACE(JOB_ID,'_','-') AS JOB_ID,
	   SALARY, SALARY * 12 AS [ANNUAL SALARY], 
	   ISNULL(CAST(COMMISSION_PCT AS VARCHAR),'NC') AS COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID, 
	   CASE WHEN SALARY < 25000/12 THEN SALARY * 12 * 0.1
			WHEN SALARY BETWEEN 25000/12 AND 50000/12 THEN SALARY * 12 * 0.2
		ELSE SALARY * 12 * 0.3 END AS TAX,
		HIRE_DATE, UPPER(SUBSTRING(DATENAME(DW,HIRE_DATE),1 ,3)) AS HIRE_DAY
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (50,80) OR HIRE_DATE BETWEEN '1997-01-01' AND '1998-12-31'
ORDER BY DEPARTMENT_ID, SALARY DESC;

--> QUESTION 2
--> DISPLAY THE MANAGER NUMBER AND THE SALARY OF MIN PAID EMPLOYEE MANAGER WISE. 
--> EXCLUDE ANYONE WITH NO MANAGER AND GROUPS WITH LOWEST SALARY LESS THAN 6000.
--> SORT BY SALARY IN DESCENDING ORDER.

SELECT MANAGER_ID, MIN(SALARY) MIN_PAID_EMP
FROM EMPLOYEES
WHERE MANAGER_ID IS NOT NULL 
GROUP BY MANAGER_ID
HAVING MIN(SALARY) >= 6000
ORDER BY MIN_PAID_EMP DESC;

													--> DAY 2 --<
--> SUBQUERY

--> SINGLE ROW SUBQUERIES --<
-->1. DETAILS OF EMPLOYEES EARNING MORE THAN EMPLOYEE ID 159
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE SALARY > (SELECT SALARY
				FROM EMPLOYEES
				WHERE EMPLOYEE_ID = 159);

-->2. DETAILS OF EMPLOYEES WHO WERE HIRED AFTER EMP ID 138
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE HIRE_DATE > (SELECT HIRE_DATE
				  FROM EMPLOYEES
				  WHERE EMPLOYEE_ID = 138);

-->3. DETAILS OF EMPLOYEES WHO EARN LESS THAN AVG SAL
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE SALARY < (SELECT AVG(ISNULL(SALARY,0))
					FROM EMPLOYEES);

-->4. DETAILS OF EMPLOYEES HIRED AFTER LAST EMPLOYEE HIRED IN DEPT 60
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE HIRE_DATE > (SELECT MAX(HIRE_DATE)
					FROM EMPLOYEES
					WHERE DEPARTMENT_ID = 60);

-->5. DETAILS OF EMPLOYEES WITH THE SAME DESIG AS EMP 172 BUT EXCLUDE EMP 172
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE JOB_ID = (SELECT JOB_ID
				FROM EMPLOYEES
				WHERE EMPLOYEE_ID = 172) AND EMPLOYEE_ID != 172;

SELECT * FROM DEPARTMENTS;

-->6. DETAILS OF EMPLOYEES WORKING IN SALES DEPARTMENT
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID
						FROM DEPARTMENTS
						WHERE DEPARTMENT_NAME = 'SALES');

-->7. DETAILS OF EMPLOYEES HIRED BEFORE 1ST EMPLOYEE WAS HIRED IN IT DEPT 60
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE HIRE_DATE < (SELECT MIN(HIRE_DATE)
				   FROM EMPLOYEES
		           WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID
										  FROM DEPARTMENTS
						                  WHERE DEPARTMENT_NAME = 'IT')
					);
	

SELECT * FROM JOBS;

-->8. DETAILS OF EMPLOYEES WHO ARE PURCHASING CLERK
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE JOB_ID = (SELECT JOB_ID 
				FROM JOBS 
				WHERE JOB_TITLE = 'PURCHASING CLERK');
			
-->9. DETAILS OF EMPLOYEES WHO EARN MORE THAN HIGHEST SALARY EARNED BY STOCK CLERK 
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE SALARY > (SELECT MAX(SALARY)
				FROM EMPLOYEES
				WHERE JOB_ID = (SELECT JOB_ID
								FROM JOBS
								WHERE JOB_TITLE = 'STOCK CLERK'));

--10. DETAILS OF EMPLOYEES WHO EARN MORE THAN AVG SALARY OF EMPLOYEES WORKING IN SHIPPING DEPARTMENT 
--   AND WHO WERE HIRED AFTER THE LAST PROGRAMMER WAS HIRED IN THE ORG.
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE SALARY > (SELECT AVG(ISNULL(SALARY,0)) 
				FROM EMPLOYEES 
				WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID 
									   FROM DEPARTMENTS 
									   WHERE DEPARTMENT_NAME = 'SHIPPING'))
	  AND HIRE_DATE > (SELECT MAX(HIRE_DATE)
					   FROM EMPLOYEES 
					   WHERE JOB_ID = (SELECT JOB_ID 
								       FROM JOBS 
									   WHERE JOB_TITLE = 'PROGRAMMER'));


--> MULTIPLE ROW SUBQUERIES --<

-->1. DETAILS OF EMPLOYEES WHO EARN MORE THAN ALL 103, 123, 180 
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE SALARY >ALL (SELECT SALARY
				   FROM EMPLOYEES
				   WHERE EMPLOYEE_ID IN (103, 123, 180));
--> >ALL INDICATES > THAN HIGHEST VALUE IN THE LIST; SO IT CAN BE REPLACED MY MAX AGGREGATION
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE SALARY > (SELECT MAX(SALARY)
				   FROM EMPLOYEES
				   WHERE EMPLOYEE_ID IN (103, 123, 180));

-->2. DETAILS OF EMPLOYEES WHO LESS MORE THAN ALL 103, 123, 180 
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE SALARY <ALL (SELECT SALARY
				   FROM EMPLOYEES
				   WHERE EMPLOYEE_ID IN (103, 123, 180));
--> <ALL INDICATES < THAN SMALLEST VALUE IN THE LIST; SO IT CAN BE REPLACED MY MIN AGGREGATION
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE SALARY < (SELECT MIN(SALARY)
				   FROM EMPLOYEES
				   WHERE EMPLOYEE_ID IN (103, 123, 180));

-->3. DETAILS OF EMPLOYEES WHO EARN MORE THAN ANY 103, 123, 180 
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE SALARY >ANY (SELECT SALARY
				   FROM EMPLOYEES
				   WHERE EMPLOYEE_ID IN (103, 123, 180));
--> >ANY IS THE SMALLEST VALUE OF THE LIST
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE SALARY > (SELECT MIN(SALARY)
				   FROM EMPLOYEES
				   WHERE EMPLOYEE_ID IN (103, 123, 180));

-->4. DETAILS OF EMPLOYEES WHO EARN LESS THAN ANY 103, 123, 180 
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE SALARY <ANY (SELECT SALARY
				   FROM EMPLOYEES
				   WHERE EMPLOYEE_ID IN (103, 123, 180));
--> <ANY IS THE LARGEST VALUE OF THE LIST
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE SALARY < (SELECT MAX(SALARY)
				   FROM EMPLOYEES
				   WHERE EMPLOYEE_ID IN (103, 123, 180));

--> PERFORMANCE ANALYSIS
SET STATISTICS IO ON;
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE SALARY >ALL (SELECT SALARY
				   FROM EMPLOYEES
				   WHERE EMPLOYEE_ID IN (103, 123, 180));
--> THIS IS SCANNED 154 TIMES

SET STATISTICS IO ON;
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE SALARY > (SELECT MAX(SALARY)
				   FROM EMPLOYEES
				   WHERE EMPLOYEE_ID IN (103, 123, 180));
--> THIS IS SCANNED ONLY 4 TIMES
--> END OF PERFORMANCE ANALYSIS

--5. DETAILS OF EMPLOYEES WHO WORK IN IT, SHIPPING AND SALES DEPARTMENTS AND WHO ARE MANAGERS
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID 
					    FROM DEPARTMENTS
					    WHERE DEPARTMENT_NAME IN ('IT', 'SALES', 'SHIPPING'))
AND JOB_ID IN(SELECT JOB_ID
			  FROM JOBS
			  WHERE JOB_TITLE LIKE '%MANAGER%');

								---------> DDL, DML & CONSTRAINTS <---------

CREATE TABLE DEPT
(
	DID INT PRIMARY KEY,
	DNAME VARCHAR(20) NOT NULL,
);

INSERT INTO DEPT(DID, DNAME) 
VALUES(20,'IT'),
	 (40,'SALES');

SELECT * FROM DEPT;

INSERT INTO DEPT(DID, DNAME)
VALUES(10,'HR'),
	  (30,'FINANCE');

INSERT INTO DEPT(DID,DNAME)
VALUES(50,'MARKETING');

SELECT * FROM DEPT;


CREATE TABLE EMP
(
	EID INT CONSTRAINT EMP_EID_PK PRIMARY KEY, --(NAME OF CONSTRAINT)
	ENAME VARCHAR(50) NOT NULL,
	SALARY FLOAT CONSTRAINT EMP_SALARY_CK CHECK(SALARY >= 10000),
	EMAIL VARCHAR(20) CONSTRAINT EMP_MAIL_UK UNIQUE,
	AADHARCARD VARCHAR(12) CONSTRAINT EMP_AC_UK UNIQUE
						   CONSTRAINT EMP_AC_CK CHECK (LEN(AADHARCARD) < 12),
	COUNTRY VARCHAR(30) CONSTRAINT EMP_COUNTRY_DF DEFAULT 'INDIA',
	GENDER CHAR(1) CONSTRAINT EMP_GENDER_CK CHECK (GENDER IN ('M','F')),
	DID INT CONSTRAINT EMP_DID_FK FOREIGN KEY REFERENCES DEPT(DID),
	MID INT CONSTRAINT EMP_MID_FK FOREIGN KEY REFERENCES EMP(EID)
);

INSERT INTO EMP(EID, ENAME, SALARY, EMAIL, AADHARCARD, COUNTRY, GENDER, DID, MID)
VALUES(1,'NIKHIL', 90000, 'N@IVP.IN', '0000', DEFAULT, 'M', 20, NULL),
	  (2, 'VIDHYA', 80000, 'V@IVP.IN', '1111', 'INDIA', 'F', 10, 1),
	  (3, 'AMIT', 70000, 'A@IVP.IN', '2222', 'UK', 'M', 20, 1),
	  (4, 'JACK', 60000, 'J@IVP.IN', '3333', 'USA', 'M', 30, 3),
	  (5, 'AMITABH', 50000, 'A1@IVP.IN', '4444', 'INDIA', 'M', NULL, NULL),
	  (6, 'ROSE', 40000, 'R@IVP.IN', '5555', 'USA', 'F', 10, 2),
	  (7, 'RAJ', 30000, 'R1@IVP.IN', '6666', DEFAULT, 'M', NULL, 3);

INSERT INTO EMP(EID, ENAME, SALARY, EMAIL, AADHARCARD, GENDER, DID, MID) 
VALUES (8, 'SONIA', 20000, 'S@IVP.IN',NULL,'F',30,4);

INSERT INTO EMP(EID, ENAME, SALARY, EMAIL, AADHARCARD, GENDER, DID, MID) 
VALUES (9, 'NEHA', 15000, 'N1@IVP.IN', '1234' ,'F',20, 3);

--> ERROR SEQUENCE ON CONSTRAINTS
--> NULL--> PRIMARY KEY--> UNIQUE--> CHECK--> DIFF TABLE FK--> SAME TABLE FK

SELECT * FROM EMP;

--> ALTER QUERIES
CREATE TABLE STUDENT  -- A HEAP TABLE; NOT SORTED AS NO PRIMARY KEY
(
	SID INT,
	SNAME VARCHAR(20),
	SUBJECT VARCHAR(20),
	MARKS FLOAT
);


INSERT INTO STUDENT(SID, SNAME, SUBJECT, MARKS)
VALUES (20,'AMIT','MATHS',80),
	   (40,'RAJESH','SCIENCE',75);

ALTER TABLE STUDENT 
			ALTER COLUMN SID INT NOT NULL;
ALTER TABLE STUDENT ADD CONSTRAINT STUDENT_SID_PK PRIMARY KEY(SID);

ALTER TABLE STUDENT
		ALTER COLUMN SNAME VARCHAR(50) NOT NULL;

ALTER TABLE STUDENT
		ADD CONSTRAINT STUDENT_SUBJECT_CK CHECK (SUBJECT IN('MATHS','SCIENCE','ENGLISH'));

ALTER TABLE STUDENT
		ADD CONSTRAINT STUDENT_MARKS_CK CHECK (MARKS BETWEEN 0 AND 100);
ALTER TABLE STUDENT
		ALTER COLUMN MARKS FLOAT NOT NULL;

alter table student
drop constraint [STUDENT_SUBJECT_CK];

ALTER TABLE STUDENT
		ADD CONSTRAINT STUDENT_SUBJECT_CK CHECK (SUBJECT IN('MATHS','SCIENCE','ENGLISH','HINDI'));

INSERT INTO STUDENT (SID,SNAME,SUBJECT,MARKS)
VALUES (60,'AMITABH','HINDI',80);

ALTER TABLE STUDENT 
	ADD GRADE VARCHAR(10);

UPDATE STUDENT
	SET GRADE = 'A' 
	WHERE MARKS >= 90;

UPDATE STUDENT
	SET GRADE = 'B' 
	WHERE MARKS BETWEEN 75 AND 89;

UPDATE STUDENT
	SET GRADE = 'C';

UPDATE STUDENT	
	SET MARKS = MARKS/2;

--OR
----UPDATE STUDENT
----SET GRADE = 'C', MARKS = MARKS/2;

ALTER TABLE STUDENT
	DROP COLUMN GRADE;


ALTER TABLE STUDENT 
	DROP CONSTRAINT STUDENT_SUBJECT_CK;

ALTER TABLE STUDENT
	DROP COLUMN SUBJECT;

SELECT * FROM STUDENT;
--> DDL AND DML IN SQL SERVER ARE AUTO COMMITTED, MEANING THEY CANNOT ROLLBACK; WE USE TRANSACTIONS FOR IT.
								
--> DELETE : ROW BY ROW OPERATION; 
-->          IT MAY OR MAY NOT RELEASE MEMORY
--> TRUNCATE : DESTROYS PAGES;
-->			 IT WILL RELEASE MEMORY
--> DROP : DESTROY THE STRUCTURE; DELETE THE DATA; RELEASE THE MEMORY

DELETE FROM STUDENT WHERE SID = '40';

INSERT INTO STUDENT VALUES (40, 'AMITABH',80);

TRUNCATE TABLE STUDENT;
-->TRUNCATE IS A DDL COMMAND NOT DML BECAUSE IT CHANGES MEMORY; IT RELEASES IT; THE .MDF FILE'S MEMORY IS PHYSICALLY DESTROYED

DROP TABLE STUDENT;	

--> MERGE: IT IS CONDITIONAL INSERT AND UPDATE
CREATE TABLE BANK
(
	CID INT PRIMARY KEY,
	CNAME VARCHAR(50) NOT NULL,
	ACCTYPE VARCHAR(50),
	BALANCE FLOAT
);

SP_HELP BANK; --TO DESCRIBE THE TABLE IN PLACE OF DESC IN MYSQL


--> MERGING TABLES MUST HAVE SAME STRUCTURE

SELECT *
INTO PROD_BANK
FROM BANK
WHERE 1 = 2; -- FALSE WHERE CONDITION TO ENSURE ONLY STRUCTURE IS MADE AND DATA ISN'T TRANSFERED; CONSTRAINTS DON'T GET CREATED

SELECT * FROM BANK;
SELECT * FROM PROD_BANK;

MERGE INTO PROD_BANK PB
USING BANK B
ON PB.CID = B.CID
WHEN MATCHED THEN 
	UPDATE
		SET PB.CNAME = B.CNAME,
			PB.ACCTYPE = B.ACCTYPE,
			PB.BALANCE = B.BALANCE
WHEN NOT MATCHED THEN
	INSERT (CID, CNAME, ACCTYPE, BALANCE)
	VALUES(B.CID, B.CNAME, B.ACCTYPE, B.BALANCE);

INSERT INTO BANK VALUES(40, 'NEHA', 'JOINT', 8765432),
					   (50, 'SUMIT', 'SAVING', 45678);

UPDATE BANK 
SET BALANCE = 11223344, ACCTYPE = 'SAVING'
WHERE CID = 10;

								-----------> JOINS <------------

-- INNER JOIN

SELECT * FROM EMP;
SELECT * FROM DEPT;

-->DETAILS OF EMPLOYEES WORKING IN DEPARTMENT. --> EID, ENAME, SALARY, DID, DNAME
--> COMPLIANT STYLE QUERY (NEW STYLE)
SELECT EMP.EID, EMP.ENAME, EMP.SALARY, DEPT.DID, DEPT.DNAME
FROM EMP INNER JOIN DEPT
ON EMP.DID = DEPT.DID;

--OR
--> PROPRIETY STYLE (OLD STYLE)
SELECT EMP.EID, EMP.ENAME, EMP.SALARY, DEPT.DID, DEPT.DNAME
FROM EMP, DEPT
WHERE EMP.DID = DEPT.DID;

SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.JOB_ID, E.SALARY, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.JOB_ID, E.SALARY, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID;


SELECT E.EMPLOYEE_ID, UPPER(CONCAT(E.FIRST_NAME,' ', E.LAST_NAME)) AS EMP_NAME, 
	   LOWER(E.EMAIL) AS EMAIL, REPLACE(E.JOB_ID,'_','-') AS JOB_ID,
	   E.SALARY, E.SALARY * 12 AS [ANNUAL SALARY], 
	   ISNULL(CAST(E.COMMISSION_PCT AS VARCHAR),'NC') AS COMMISSION_PCT, E.MANAGER_ID, D.DEPARTMENT_ID, D.DEPARTMENT_NAME,
	   CASE WHEN SALARY < 25000/12 THEN SALARY * 12 * 0.1
			WHEN SALARY BETWEEN 25000/12 AND 50000/12 THEN SALARY * 12 * 0.2
		ELSE SALARY * 12 * 0.3 END AS TAX,
		HIRE_DATE, UPPER(SUBSTRING(DATENAME(DW,HIRE_DATE),1 ,3)) AS HIRE_DAY
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.DEPARTMENT_ID IN (50,80) OR HIRE_DATE BETWEEN '1997-01-01' AND '1998-12-31'
ORDER BY DEPARTMENT_ID, SALARY DESC;

SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.JOB_ID, E.SALARY, D.DEPARTMENT_ID, D.DEPARTMENT_NAME, J.JOB_TITLE
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
INNER JOIN JOBS J
ON E.JOB_ID = J.JOB_ID;

SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.JOB_ID, E.SALARY, D.DEPARTMENT_ID, D.DEPARTMENT_NAME, J.JOB_TITLE
FROM EMPLOYEES E, DEPARTMENTS D, JOBS J
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND E.JOB_ID = J.JOB_ID;

--PROPRIETY STYLE
SELECT DEPARTMENT_NAME, COUNT(EMPLOYEE_ID) AS [NO OF EMPLOYEES], SUM(SALARY) AS [TOTAL SALARY]
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY DEPARTMENT_NAME;

--COMPLIANT STYLE
SELECT D.DEPARTMENT_NAME, COUNT(E.EMPLOYEE_ID) AS [NO_OF_EMPLOYEES], SUM(E.SALARY) AS [TOTAL_SALARY]
FROM DEPARTMENTS D INNER JOIN EMPLOYEES E   ---- KEEP SMALLER TABLES ON LEFT SIDE; JOINS WORK FASTER
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY DEPARTMENT_NAME;

SELECT J.JOB_TITLE, COUNT(E.EMPLOYEE_ID) AS EMP_COUNT, 
	   CONVERT(VARCHAR, MIN(E.HIRE_DATE), 105) AS FIRST_EMP, 
	   CONVERT(VARCHAR,MAX(E.HIRE_DATE),105) AS LAST_EMP
FROM JOBS J INNER JOIN EMPLOYEES E
ON E.JOB_ID = J.JOB_ID
GROUP BY J.JOB_TITLE;

SELECT J.JOB_TITLE, COUNT(E.EMPLOYEE_ID) AS EMP_COUNT, 
	   CONVERT(VARCHAR, MIN(E.HIRE_DATE), 105) AS FIRST_EMP, 
	   CONVERT(VARCHAR,MAX(E.HIRE_DATE),105) AS LAST_EMP,
	   SUM(DATEDIFF(YYYY,E.HIRE_DATE,GETDATE())) AS TOTAL_DEPT_EXP
FROM JOBS J INNER JOIN EMPLOYEES E
ON E.JOB_ID = J.JOB_ID
GROUP BY J.JOB_TITLE;

SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, D.DEPARTMENT_ID, E.MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT 
FROM DEPARTMENTS D INNER JOIN EMPLOYEES E
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE D.DEPARTMENT_NAME = 'SALES';

SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID, MANAGER_ID, 
	   HIRE_DATE, COMMISSION_PCT
FROM EMPLOYEES
WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID 
			    FROM DEPARTMENTS 
				WHERE DEPARTMENT_NAME = 'SALES');

--> BOTH SUBQUERY AND JOIN IS USED TO SOLVE THE SAME REQUIREMENT 
--> BUT SUBQUERY IS FASTER THAN JOINS AVOIDING UNNECESSARY COMPARISONS.
--> THEREFORE PREFER SUBQUERIES FOR LARGE TABLES OR DATA.