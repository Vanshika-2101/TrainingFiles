USE AdventureWorks2017;

--DMV - DYNAMIC MANAGEMENT VIEWS -- SYSTEM TABLES
--TO VIEW ALL DATABASES
SELECT * FROM SYS.DATABASES; 
--CURRENT VERSION
SELECT @@VERSION; 
--DATABASE FILES IN CURR DB
SELECT * FROM SYS.database_files;
--DB TABLES IN CURR DB
SELECT * FROM SYS.TABLES;
SELECT * FROM SYS.COLUMNS;

USE IVP3686;
SELECT * FROM SYS.TABLES;
SELECT * FROM SYS.COLUMNS;

--> ALL OBJECTS
SELECT * FROM SYS.OBJECTS;

SELECT DISTINCT TYPE, TYPE_DESC
FROM SYS.OBJECTS;

SELECT T.NAME AS TABLE_NAME, C.NAME AS COLUMN_NAME
FROM SYS.TABLES AS T INNER JOIN SYS.COLUMNS AS C
ON T.OBJECT_ID = C.OBJECT_ID
WHERE C.NAME LIKE '%DEP%';

-- ABOVE IS THE DMV WAY OF FINDNG DEPENDENCIES

--CREATING VIEW
CREATE VIEW EMPVIEW
AS 
SELECT * FROM EMPLOYEES;

SELECT * FROM SYS.OBJECTS 
WHERE TYPE = 'U';  --WHEN TABLE INFO IS NEEDED; THIS IS SYS.TABLES

SELECT * FROM SYS.key_constraints;
SELECT * FROM SYS.TABLES;

SELECT T.NAME AS TABLE_NAME, C.NAME AS COL_NAME, KC.NAME AS CONSTRAINT_NAME
FROM SYS.TABLES T INNER JOIN SYS.columns C
ON T.object_id = C.object_id
INNER JOIN SYS.key_constraints KC
ON T.object_id = KC.parent_object_id;

--SCHEMA IS A COLLECTION OF OBJECTS
-- dbo IS DEFAULT SCHEMA IN SQL SERVER.
--SCHEMA DESIGNING
SELECT * FROM SYS.SCHEMAS;

CREATE SCHEMA SALES;

--TABLE IN THAT SCHEMA
CREATE TABLE SALES.PRODUCT 
(
	PID INT PRIMARY KEY,
	PNAME VARCHAR(20) NOT NULL,
	PRICE FLOAT
);

--ALWAYS HANDY QUERIES
SELECT * FROM SYS.SCHEMAS;
SELECT * FROM SYS.TABLES;
SELECT * FROM SYS.COLUMNS;

SELECT S.NAME, T.NAME, C.NAME
FROM SYS.SCHEMAS S INNER JOIN SYS.TABLES T
ON S.SCHEMA_ID = T.schema_id
INNER JOIN SYS.COLUMNS C
ON T.object_id = C.object_id
WHERE C.NAME LIKE '%SHIFT%';



USE AdventureWorks2017;
SELECT S.NAME, T.NAME, C.NAME
FROM SYS.SCHEMAS S INNER JOIN SYS.TABLES T
ON S.SCHEMA_ID = T.schema_id
INNER JOIN SYS.COLUMNS C
ON T.object_id = C.object_id
WHERE C.NAME LIKE '%SHIFT%';

--IF TABLES DMV IS NOT TO BE USED, YOU WISH TO USE OBJECT DMV:
SELECT S.NAME, T.NAME, C.NAME
FROM SYS.SCHEMAS S INNER JOIN SYS.OBJECTS T
ON S.SCHEMA_ID = T.schema_id
INNER JOIN SYS.COLUMNS C
ON T.object_id = C.object_id
WHERE C.NAME LIKE '%SHIFT%'
AND T.TYPE = 'U';


--BACK TO DAY 2 JOINS

SELECT E.BusinessEntityID, P.FirstName, P.LastName, E.JobTitle, E.HireDate, D.Name AS DEPARTMENT_NAME, D.GroupName,
	   S.NAME AS SHIFTNAME, S.StartTime, S.EndTime
FROM HumanResources.EmployeeDepartmentHistory EDH INNER JOIN HumanResources.Employee E
ON EDH.BusinessEntityID = E.BusinessEntityID
INNER JOIN HumanResources.Department D
ON EDH.DepartmentID = D.DepartmentID
INNER JOIN HumanResources.Shift S
ON EDH.ShiftID = S.ShiftID
INNER JOIN PERSON.PERSON P
ON E.BusinessEntityID = P.BusinessEntityID
ORDER BY 1;

SELECT E.BusinessEntityID, P.FirstName, P.LastName, E.JobTitle, E.HireDate, 
	   D.Name AS DEPARTMENT_NAME, D.GroupName,
	   S.NAME AS SHIFTNAME, S.StartTime, S.EndTime, PP.PHONENUMBER, EA.EmailAddress
FROM HumanResources.EmployeeDepartmentHistory EDH INNER JOIN HumanResources.Employee E
ON EDH.BusinessEntityID = E.BusinessEntityID
INNER JOIN HumanResources.Department D
ON EDH.DepartmentID = D.DepartmentID
INNER JOIN HumanResources.Shift S
ON EDH.ShiftID = S.ShiftID
INNER JOIN PERSON.PERSON P
ON E.BusinessEntityID = P.BusinessEntityID
INNER JOIN PERSON.PERSONPHONE PP
ON E.BUSINESSENTITYID = PP.BUSINESSENTITYID
INNER JOIN Person.EmailAddress EA
ON E.BusinessEntityID = EA.BusinessEntityID
ORDER BY 1;

--TYPE OF PHONE NO.
SELECT E.BusinessEntityID, P.FirstName, P.LastName, E.JobTitle, E.HireDate, 
	   D.Name AS DEPARTMENT_NAME, D.GroupName,
	   S.NAME AS SHIFTNAME, S.StartTime, S.EndTime, PP.PHONENUMBER, PNT.Name AS PHONE_TYPE, EA.EmailAddress
FROM HumanResources.EmployeeDepartmentHistory EDH INNER JOIN HumanResources.Employee E
ON EDH.BusinessEntityID = E.BusinessEntityID
INNER JOIN HumanResources.Department D
ON EDH.DepartmentID = D.DepartmentID
INNER JOIN HumanResources.Shift S
ON EDH.ShiftID = S.ShiftID
INNER JOIN PERSON.PERSON P
ON E.BusinessEntityID = P.BusinessEntityID
INNER JOIN PERSON.PERSONPHONE PP
ON E.BUSINESSENTITYID = PP.BUSINESSENTITYID
INNER JOIN Person.EmailAddress EA
ON E.BusinessEntityID = EA.BusinessEntityID
INNER JOIN Person.PhoneNumberType PNT
ON PP.PhoneNumberTypeID = PNT.PhoneNumberTypeID
ORDER BY 1;

--CITY, STATE, COUNTRY

SELECT E.BusinessEntityID, P.FirstName, P.LastName, E.JobTitle, E.HireDate, 
	   D.Name AS DEPARTMENT_NAME, D.GroupName,
	   S.NAME AS SHIFTNAME, S.StartTime, S.EndTime, PP.PHONENUMBER, PNT.Name AS PHONE_TYPE, EA.EmailAddress,
	   A.CITY AS CITY, SP.NAME AS STATE, CR.NAME AS COUNTRY
FROM HumanResources.EmployeeDepartmentHistory EDH INNER JOIN HumanResources.Employee E
ON EDH.BusinessEntityID = E.BusinessEntityID
INNER JOIN HumanResources.Department D
ON EDH.DepartmentID = D.DepartmentID
INNER JOIN HumanResources.Shift S
ON EDH.ShiftID = S.ShiftID
INNER JOIN PERSON.PERSON P
ON E.BusinessEntityID = P.BusinessEntityID
INNER JOIN PERSON.PERSONPHONE PP
ON E.BUSINESSENTITYID = PP.BUSINESSENTITYID
INNER JOIN Person.EmailAddress EA
ON E.BusinessEntityID = EA.BusinessEntityID
INNER JOIN Person.PhoneNumberType PNT
ON PP.PhoneNumberTypeID = PNT.PhoneNumberTypeID
INNER JOIN PERSON.BusinessEntityAddress BEA
ON E.BusinessEntityID = BEA.BusinessEntityID
INNER JOIN Person.Address A
ON A.AddressID = BEA.AddressID
INNER JOIN Person.StateProvince SP
ON A.StateProvinceID = SP.StateProvinceID
INNER JOIN PERSON.CountryRegion CR
ON SP.CountryRegionCode = CR.CountryRegionCode
ORDER BY 1;

										------> OUTER JOINS <-------
USE IVP3686;
--> EMPLOYEES WORKING IN DEPARTMENTS
SELECT E.EID, E.ENAME, E.SALARY, D.DID, D.DNAME
FROM EMP E INNER JOIN DEPT D
ON E.DID = D.DID;

--> EMPLOYEES WORKING IN DEPARTMENTS AND EMPLOYEES WITHOUT ANY DEPT
SELECT E.EID, E.ENAME, E.SALARY, D.DID, D.DNAME
FROM EMP E LEFT OUTER JOIN DEPT D  --OUTER KEYWORD IS OPTIONAL
ON E.DID = D.DID;

SELECT E.EID, E.ENAME, E.SALARY, D.DID, D.DNAME
FROM DEPT D RIGHT OUTER JOIN EMP E  --OUTER KEYWORD IS OPTIONAL
ON E.DID = D.DID;

-- WE KEEP THE SMALLER TABLE ON THE LEFT ALWAYS
-- NOTE:- WE WILL ONLY FOCUS ON TABLES HAVING MORE THAN 1000 PAGES FOR PERFORMANCE TUNING.
-- OUTER JOINS ONLY WORK WITH COMPLIANT STYLE

--> EMPLOYEES WORKING IN DEPARTMENTS AND EMPTY DEPT
SELECT E.EID, E.ENAME, E.SALARY, D.DID, D.DNAME
FROM DEPT D LEFT JOIN EMP E
ON E.DID = D.DID;

--> EMPLOYEES WORKING IN DEPARTMENTS AND EMPTY DEPT AND EMPLOYEES WITH NO DEPT
SELECT E.EID, E.ENAME, E.SALARY, D.DID, D.DNAME
FROM DEPT D FULL JOIN EMP E
ON E.DID = D.DID;
-- EXECUTION WISE, FULL OUTER JOIN FETCHES LEFT SIDE FIRST, THEN THE RIGHT

--> TO ACCESS ANY TABLE FROM TWO DIFF DATABASES
--SELECT *
--FROM AdventureWorks2017.HumanResources.Employee E FULL JOIN IVP3686.DBO.EMP E

--> EID, LASTNAME, SAL, HD, JOBID, DID, DNAME, JT
-- FOR ALL THE EMPLOYEES

SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.SALARY, E.HIRE_DATE, J.JOB_ID, D.DEPARTMENT_ID, D.DEPARTMENT_NAME, J.JOB_TITLE 
FROM EMPLOYEES E LEFT JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
INNER JOIN JOBS J
ON J.JOB_ID = E.JOB_ID

-- DN WISE, JOB TITLE WISE, NO OF EMP AND MAX SAL FOR ALL DEPT

SELECT D.DEPARTMENT_NAME, ISNULL(J.JOB_TITLE,'NA') AS JOB_TITLE, COUNT(E.EMPLOYEE_ID) AS EMP_COUNT, 
	   ISNULL(MAX(E.SALARY),0) AS MAX_SAL   --PREVENTING NULL IN O/P USING ISNULL
FROM DEPARTMENTS D LEFT JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
LEFT JOIN JOBS J
ON J.JOB_ID = E.JOB_ID
GROUP BY D.DEPARTMENT_NAME, J.JOB_TITLE
ORDER BY D.DEPARTMENT_NAME, J.JOB_TITLE;

USE AdventureWorks2017;

SELECT * FROM Production.Product;
SELECT * FROM Production.WorkOrder;

--> PDT_ID, PDT_NAME, NO OF WORK ORDER RECEIVED
SELECT P.ProductID AS PRODUCT_ID, P.Name AS PRODUCT_NAME, COUNT(W.WorkOrderID) AS TOTAL_ORDERS
FROM Production.Product P LEFT JOIN Production.WorkOrder W
ON P.ProductID = W.ProductID
GROUP BY P.ProductID, P.NAME
ORDER BY 1,2;

-- NOTE:- COUNT OF NULL IS ZERO

										-------> SELF JOIN <--------
-- NIKHIL IS A MANAGER OF VIDHYA
-- NIKHIL IS A MANAGER OF AMIT; WE WANT A HIERARCHY

USE IVP3686

SELECT * FROM EMP;

SELECT CONCAT(M.ENAME, ' IS A MANAGER OF ', W.ENAME) AS REPORTING_STRUCTURE
FROM EMP M INNER JOIN EMP W
ON M.EID = W.MID;

SELECT W.LAST_NAME AS EMP_NAME, W.EMPLOYEE_ID AS EMP_NUM, M.LAST_NAME AS MAN_NAME, M.EMPLOYEE_ID AS MAN_NUM
FROM EMPLOYEES M INNER JOIN EMPLOYEES W
ON M.EMPLOYEE_ID = W.MANAGER_ID;

SELECT W.LAST_NAME AS EMP_NAME, W.EMPLOYEE_ID AS EMP_NUM, M.LAST_NAME AS MAN_NAME, M.EMPLOYEE_ID AS MAN_NUM
FROM EMPLOYEES M right JOIN EMPLOYEES W
ON M.EMPLOYEE_ID = W.MANAGER_ID;

SELECT W.LAST_NAME AS EMP_NAME, W.HIRE_DATE AS W_H_D, M.LAST_NAME AS MAN_NAME, m.hire_date as m_h_d
FROM EMPLOYEES M JOIN EMPLOYEES W
ON M.EMPLOYEE_ID = W.MANAGER_ID
WHERE W.HIRE_DATE < M.HIRE_DATE;

SELECT * FROM EMPLOYEES;

select w.last_name, w.SALARY
from EMPLOYEES m join EMPLOYEES w
on w.MANAGER_ID = m.EMPLOYEE_ID
where m.LAST_NAME = 'king';

									-----------> VIEWS <-----------
CREATE VIEW VU_EMP_MANAGEGR
AS
	SELECT W.LAST_NAME AS EMP_NAME, W.EMPLOYEE_ID AS EMP_NUM, M.LAST_NAME AS MAN_NAME, M.EMPLOYEE_ID AS MAN_NUM
	FROM EMPLOYEES M INNER JOIN EMPLOYEES W
	ON M.EMPLOYEE_ID = W.MANAGER_ID;

SELECT * FROM SYS.VIEWS

--> WE CANNOT USE ORDER BY CALUSE IN A VIEW
--> VIEWS ALWAYS FETCH DATA FROM BASE TABLE; THEY'RE JUST LOGICAL REPRESENTATION

SELECT * FROM VU_EMP_MANAGEGR
ORDER BY EMP_NAME;

SP_SPACEUSED EMPLOYEES;

SP_SPACEUSED VU_EMP_MANAGEGR;


USE AdventureWorks2017;
CREATE VIEW VU_ADV_WORK_DETAILS
AS
SELECT E.BusinessEntityID, P.FirstName, P.LastName, E.JobTitle, E.HireDate, 
	   D.Name AS DEPARTMENT_NAME, D.GroupName,
	   S.NAME AS SHIFTNAME, S.StartTime, S.EndTime, PP.PHONENUMBER, PNT.Name AS PHONE_TYPE, EA.EmailAddress,
	   A.CITY AS CITY, SP.NAME AS STATE, CR.NAME AS COUNTRY
FROM HumanResources.EmployeeDepartmentHistory EDH INNER JOIN HumanResources.Employee E
ON EDH.BusinessEntityID = E.BusinessEntityID
INNER JOIN HumanResources.Department D
ON EDH.DepartmentID = D.DepartmentID
INNER JOIN HumanResources.Shift S
ON EDH.ShiftID = S.ShiftID
INNER JOIN PERSON.PERSON P
ON E.BusinessEntityID = P.BusinessEntityID
INNER JOIN PERSON.PERSONPHONE PP
ON E.BUSINESSENTITYID = PP.BUSINESSENTITYID
INNER JOIN Person.EmailAddress EA
ON E.BusinessEntityID = EA.BusinessEntityID
INNER JOIN Person.PhoneNumberType PNT
ON PP.PhoneNumberTypeID = PNT.PhoneNumberTypeID
INNER JOIN PERSON.BusinessEntityAddress BEA
ON E.BusinessEntityID = BEA.BusinessEntityID
INNER JOIN Person.Address A
ON A.AddressID = BEA.AddressID
INNER JOIN Person.StateProvince SP
ON A.StateProvinceID = SP.StateProvinceID
INNER JOIN PERSON.CountryRegion CR
ON SP.CountryRegionCode = CR.CountryRegionCode;

--> ALTER VIEW -- SAME AS ABOVE
--> DROP VIEW VIEWNAME

USE IVP3686;
CREATE VIEW VU_ANSWER
AS 
	SELECT D.DEPARTMENT_NAME, COUNT(E.EMPLOYEE_ID) AS COUNT, SUM(E.SALARY) AS TOTALSAL, ISNULL(AVG(E.SALARY),0) AS AVGSAL
	FROM DEPARTMENTS D INNER JOIN EMPLOYEES E
	ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
	WHERE D.DEPARTMENT_ID IN (SELECT DEPARTMENT_ID
						    FROM EMPLOYEES
							WHERE EMPLOYEE_ID IN (103, 135,178,192))
	GROUP BY DEPARTMENT_NAME;

SELECT * FROM VU_ANSWER;

--> WE CAN PERFORM DML OPERATIONS ON A VIEW
--> TO MAKE VIEWS READ-ONLY WE CREATE INSTEAD OF TRIGGERS ON A VIEW

--DML OPS ON VIEWS
--SOME PROPS ON VIEWS: WITH ENCYPTION; WITH SCHEMABINDING; WITH CHECK CONSTRAINT