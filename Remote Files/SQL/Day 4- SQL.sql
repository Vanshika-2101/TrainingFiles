-- VIEWS --
--> DML OPERATIONS ON VIEWS <--
USE IVP3686;
SELECT * FROM BANK;

CREATE VIEW VUSAVINGACCOUNT
AS
	SELECT * FROM BANK
	WHERE ACCTYPE = 'SAVING';

SELECT * FROM VUSAVINGACCOUNT;

SP_SPACEUSED VUSAVINGACCOUNT;

INSERT INTO VUSAVINGACCOUNT(CID, CNAME, ACCTYPE, BALANCE) 
VALUES (60, 'RAJESH', 'SAVING', 999888);

-- ANY CHANGES ON A VIEW WILL HAPPEN ON A BASE TABLE

INSERT INTO VUSAVINGACCOUNT(CID, CNAME, ACCTYPE, BALANCE) 
VALUES (70, 'RAMESH', 'JOINT', 799888);

ALTER VIEW VUSAVINGACCOUNT
AS
	SELECT * FROM BANK
	WHERE ACCTYPE = 'SAVING'
	WITH CHECK OPTION;

INSERT INTO VUSAVINGACCOUNT(CID, CNAME, ACCTYPE, BALANCE) 
VALUES (80, 'SURESH', 'CURRENT', 699888);
 -- APPLYING WITH CHECK OPTION WILL CHECK THE WHERE CLAUSE CONDITION BEFORE INSERT AND UPDATE.
 -- IF THE CONDITION SATISY, THEN THE TRANSACTION IS ALLOWED. TRANSACTION MEANS DML OPERATION.

CREATE VIEW VUCURRENTACCOUNT
AS
	SELECT CID, ACCTYPE, BALANCE FROM BANK
	WHERE ACCTYPE = 'CURRENT';

SELECT * FROM VUCURRENTACCOUNT;

INSERT INTO VUCURRENTACCOUNT (CID, ACCTYPE, BALANCE)
VALUES (80, 'CURRENT', 98765);
-- THROWS ERROR BECAUSE CNAME COL IN BASE TABLE IS NOT NULL AND IT MUST EXIST IN THE VIEW IF INSERT IS TO BE APPLIED
-- DML OPERATION IS ONLY ALLOWED ON SIMPLE VIEW
-- SIMPLE VIEW IS A VIEW BASED ON SINGLE TABLE, AND SHOULD NOT HAVE ANY CALCULATED COLUMNS

SELECT * FROM BANK;
SELECT * FROM VUSAVINGACCOUNT;
SELECT * FROM VUCURRENTACCOUNT;

UPDATE VUSAVINGACCOUNT
SET BALANCE = BALANCE + 1000;

UPDATE VUSAVINGACCOUNT
SET ACCTYPE = 'CURRENT'
WHERE CID = 60; -- GIVES ERROR

UPDATE VUCURRENTACCOUNT
SET BALANCE = 9988877
WHERE CID = 30;

UPDATE VUCURRENTACCOUNT
SET BALANCE = 9988877
WHERE CID = 10; -- DOESN'T MAKE ANY CHANGE BECAUSE CID 10 IS NOT PART OF THIS VIEW

--UPDATE AND DELETE CAN BE DONE ONLY ON RECORDS PRESENT IN A VIEW

DELETE FROM VUCURRENTACCOUNT 
WHERE CID = 10; --WILL NOT HAPPEN

DELETE FROM VUSAVINGACCOUNT
WHERE CID = 60; --SUCCESSFUL

-- WITH ENCYPTION
SELECT * FROM SYS.VIEWS;
SELECT * FROM SYS.syscomments; --GIVES DEFINITION OF WHATEVER OBJECT YOU CREATE UNDER TEXT COLUMN

-- WITH ENCYPTION IS TO PREVENT THIS SCRIPT FROM BEING ACCESSIBLE
-- IT WILL HIDE THE LOGIC WRITTEN

CREATE VIEW VUPREMIUMCUSTOMERS
AS
	SELECT * FROM BANK
	WHERE BALANCE >= 500000;

ALTER VIEW VUPREMIUMCUSTOMERS
WITH ENCRYPTION
AS
	SELECT * FROM BANK
	WHERE BALANCE >= 500000;

SP_WHO2; -- TO SEE BACKGROUND PROCESSES AND MEMORY -- HERE MEMORY IS RAM
SELECT @@VERSION;

-- WITH SCHEMA BINDING
-- IF WE DROP A TABLE, THE VIEWS CREATED ON IT BECOME INVALID

-- IDEALLY, IT SHOULD NOT ALLOW FOR THE TABLE TO BE DROPPED, IF A VIEW ON IT EXISTS; 
-- THIS IS WHERE SCHEMA BINDING COMES IN
-- IT CREATES A DEPENDENCY BETWEEN A TABLE AND VIEW.
-- * IS NOT ALLOWED IN THE SYNTAX
-- THE TABLE NAME MUST BE IN TWO PART FORMAT <SCHEMA_NAME>.<TABLE_NAME>

CREATE VIEW VUJOINTACCOUNT
WITH SCHEMABINDING
AS
	SELECT CID, CNAME, ACCTYPE, BALANCE FROM DBO.BANK --ALL COL NAMES AND SCHEMA NAME; TWO-PART FORMAT OF BASE TABLE NAME
	WHERE ACCTYPE = 'JOINT';

DROP TABLE BANK; --SINCE THE TABLE IS NOW REFERENCED BY A VIEW, IT CANNOT BE DROPPED.

-- WE CAN USE SCHEMABINDING AND ENCYPTION TOGETHER
ALTER VIEW VUJOINTACCOUNT
WITH SCHEMABINDING, ENCRYPTION
AS 
	SELECT CID, CNAME, ACCTYPE, BALANCE
	FROM DBO.BANK
	WHERE ACCTYPE = 'JOINT';

ALTER TABLE BANK
ADD COUNTRY VARCHAR(20) DEFAULT 'INDIA' NOT NULL;

SELECT * FROM BANK;

										-----> SET OPERATORS <-----
--
CREATE TABLE CREDITCARD
(	
	CID INT PRIMARY KEY,
	CNAME VARCHAR(50) NOT NULL,
	CARDTYPE VARCHAR(50),
	AMOUNT FLOAT
);

CREATE TABLE HOMELOAN
(	
	CID INT PRIMARY KEY,
	CNAME VARCHAR(50) NOT NULL,
	LOANTYPE VARCHAR(50),
	AMOUNT FLOAT
);

INSERT INTO CREDITCARD 
VALUES (10, 'NIKHIL', 'CREDIT CARD', 909090),
	   (20, 'JACK', 'CREDIT CARD', 808080),
	   (40, 'RITA', 'CREDIT CARD', 707070),
	   (60, 'SONIA', 'CREDIT CARD', 606060);

INSERT INTO HOMELOAN
VALUES (10, 'NIKHIL', 'HOME LOAN', 999999),
	   (20, 'JACK', 'HOME LOAN', 555555),
	   (30, 'NILESH', 'HOME LOAN', 333333),
	   (50, 'NEHA', 'HOME LAON', 888888);

-- INTERSECT --
-- DETAILS OF CUSTOMERS WHO HAVE AVAILED BOTH THE SERVICES
SELECT CID, CNAME
FROM CREDITCARD
INTERSECT
SELECT CID, CNAME
FROM HOMELOAN;
-- CAN BE DONE BY JOINS TOO BUT THIS IS WHEN THE STRUCTURE NEEDS TO BE SAME; THIS IS A VERTICAL COMPARISON
-- JOINS IS BETTER; FOR BIGGER TABLES, WE USE JOINS
-- NO. OF COLUMNS HERE MUST BE SAME
-- DATA TYPES OF COLUMNS MUST BE SAME
-- COLUMNS MUST BE IN A PROPER SEQUENCE WITH MATCHING DATA TYPES
-- ORDER BY CAN BE USED ONLY AT THE END OF QUERY
SELECT CID, CNAME
FROM CREDITCARD
INTERSECT
SELECT CID, CNAME
FROM HOMELOAN
ORDER BY 1 DESC;

-- EXCEPT A-B
-- DETAILS OF CUSTOMERS WHO HAVE ONLY OPTED FOR CREDIT CARDS
SELECT CID, CNAME
FROM CREDITCARD
EXCEPT
SELECT CID, CNAME
FROM HOMELOAN;

-- EXCEPT B-A
-- DETAILS OF CUSTOMERS WHO HAVE ONLY OPTED FOR HOME LOANS
SELECT CID, CNAME
FROM HOMELOAN
EXCEPT
SELECT CID, CNAME
FROM CREDITCARD;

-- UNION
-- DETAILS OF CUTOMERS WHO HAVE OPTED FOR BOTH (WITHOUT REPETITION OF COMMON DATA)
SELECT CID, CNAME
FROM CREDITCARD
UNION
SELECT CID, CNAME
FROM HOMELOAN;

-- UNION ALL
-- DETAILS OF CUTOMERS WHO HAVE OPTED FOR BOTH (WITH REPETITION OF COMMON DATA)
SELECT CID, CNAME
FROM CREDITCARD
UNION ALL
SELECT CID, CNAME
FROM HOMELOAN;
-- TABLE A + TABLE B EXECUTION

-- COLUMN NAME OF FIRST TABLE WILL BE DISPLAYED IN THE OUTPUT
SELECT CID, CNAME, CARDTYPE AS SERVICES
FROM CREDITCARD
UNION ALL
SELECT CID, CNAME, LOANTYPE
FROM HOMELOAN;

-- JOIN IS A HORIZONTAL COMPARISON OF DATA WHEREAS SET OPERATORS ARE A VERTICAL COMPARISON OF DATA

							------> CROSS JOIN / CARTESIAN PRODUCT <------
-- ALL RECORDS OF ONE TABLE WILL BE JOINED WITH ALL RECORDS OF ANOTHER TABLE
-- 1. DATA COMPARISON
-- 2. COMBINATIONS OF DATA
-- THERE ARE NO ON CLAUSES IN CROSS JOIN

SELECT E1.EID, E1.ENAME, E1.SALARY, E2.SALARY, E2.ENAME, E2.EID
FROM EMP E1 CROSS JOIN EMP E2;

SELECT E1.EID, E1.ENAME, E1.SALARY, E2.SALARY, E2.ENAME, E2.EID
FROM EMP E1 CROSS JOIN EMP E2
WHERE E1.EID <> E2.EID;

SELECT E1.EID, E1.ENAME, E1.SALARY, E2.SALARY, E2.ENAME, E2.EID
FROM EMP E1 CROSS JOIN EMP E2
WHERE E1.EID <> E2.EID
AND E2.EID = 1;

CREATE TABLE GROUPA
(
	TEAMID INT PRIMARY KEY IDENTITY(1,1), --IT'LL START WITH 1 AND AUTOMATICALLY INCREASE BY 1; IT IS ONLY NUMERIC
	TEAMNAME VARCHAR(20) NOT NULL
);

CREATE TABLE GROUPB
(
	TEAMID INT PRIMARY KEY IDENTITY(10,10),
	TEAMNAME VARCHAR(20) NOT NULL
);

INSERT INTO GROUPA(TEAMNAME)
VALUES
('INDIA'),
('NEPAL'),
('AUSTRALIA');

INSERT INTO GROUPB(TEAMNAME)
VALUES
('ENGLAND'),
('SOUTH AFRICA'),
('PAKISTAN');

SELECT A.TEAMNAME + ' VS ' + B.TEAMNAME AS MATCHES
FROM GROUPA A
CROSS JOIN GROUPB B


							-------------> STORED PROCEDURES <--------------
-- IT IS A SET OF SQL AND T-SQL (T STANDS FOR TRASACTIONS) STATEMENTS 
-- IT IS STORED AS A DAYABASE OBJECT.
-- IT IS A SHARABLE OBJECT.
-- REUSABILITY OF CODE + REUSABILITY OF EXECUTION PLAN. (WRITE ONCE AND USE N NUMBER OF TIMES)
-- IT CAN BE USED FROM SECURITY PERSPECTIVE
-- WE CAN MAKE OUR QUERIES DYNAMIC (USING VARIABLES)

-- NOTE: DO NOT START PROCEDURE NAME WITH "SP_"; WE GENERALLY USE "USP_" FOR USER DEFINED STORED PROCEDURES

-- CREATION OF A STORED PROCEDURE
-- STATIC STORED PROCEDURE
CREATE PROCEDURE USP_EMPDETAILS
AS
 BEGIN
	SELECT *
	FROM EMPLOYEES
	WHERE DEPARTMENT_ID = 30;
 END;

--EXECUTION OF A STORED PROCEDURE

EXEC USP_EMPDETAILS; -- RECOMMENDED WAY
--OR
EXECUTE USP_EMPDETAILS;
--OR
USP_EMPDETAILS;

-- ALTERING THE STORED PROCEDURE

ALTER PROCEDURE USP_EMPDETAILS
AS
 BEGIN
	SELECT EMPLOYEE_ID, CONCAT(FIRST_NAME, ' ', LAST_NAME) AS EMP_NAME,
		   SALARY, JOB_ID, HIRE_DATE, DEPARTMENT_ID
	FROM EMPLOYEES
	WHERE DEPARTMENT_ID = 50;
 END;

-- DROPPING A STORED PROCEDURE
DROP PROCEDURE USP_EMPDETAILS;

-- FOR A DYNAMIC ID VALUE
-- DYNAMIC / PARAMETRIZED STORED PROCEDURE

ALTER PROCEDURE USP_EMPDETAILS @ID INT
AS
 BEGIN
	SELECT EMPLOYEE_ID, CONCAT(FIRST_NAME, ' ', LAST_NAME) AS EMP_NAME,
		   SALARY, JOB_ID, HIRE_DATE, DEPARTMENT_ID
	FROM EMPLOYEES
	WHERE DEPARTMENT_ID = @ID;
 END;

EXEC USP_EMPDETAILS @ID = 60;
EXEC USP_EMPDETAILS @ID = 90;

-- DEPT NAME, EMP ID, LAST NAME, SALARY, HIRE DATE, JOB TITLE
-- FOR ALL THE EMPLOYEES WORKING IN SALES DEPARTMENT AND WHOSE SALARY IS GREATER THAN 5000
CREATE PROC USP_EMPLOYEEDETAILS
AS
BEGIN
	SELECT D.DEPARTMENT_NAME, E.EMPLOYEE_ID, E.LAST_NAME, E.SALARY, E.HIRE_DATE, J.JOB_TITLE
	FROM DEPARTMENTS D INNER JOIN EMPLOYEES E
	ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
	INNER JOIN JOBS J
	ON J.JOB_ID = E.JOB_ID
	WHERE DEPARTMENT_NAME = 'SALES'
	AND SALARY >= 5000;
END

EXEC USP_EMPLOYEEDETAILS;

ALTER PROC USP_EMPLOYEEDETAILS @NAME VARCHAR(50), @SAL FLOAT
AS 
BEGIN
	SELECT D.DEPARTMENT_NAME, E.EMPLOYEE_ID, E.LAST_NAME, E.SALARY, E.HIRE_DATE, J.JOB_TITLE
	FROM DEPARTMENTS D INNER JOIN EMPLOYEES E
	ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
	INNER JOIN JOBS J
	ON J.JOB_ID = E.JOB_ID
	WHERE DEPARTMENT_NAME = @NAME
	AND SALARY >= @SAL;
END

EXEC USP_EMPLOYEEDETAILS @NAME = 'SALES', @SAL = 10000; -- NAMED WAY OF PASSING PARAMETERS
EXEC USP_EMPLOYEEDETAILS @NAME = 'SHIPPING', @SAL = 5000;
EXEC USP_EMPLOYEEDETAILS @NAME = 'IT', @SAL = 6000;
EXEC USP_EMPLOYEEDETAILS 'IT', 6000; -- POSITIONAL WAY OF PASSING PARAMETERS
EXEC USP_EMPLOYEEDETAILS 'SHIPPING', @SAL = 5000; -- COMBINATION, AFTER ONE NAMED PARAMETER, ALL SHOULD BE NAMED

SELECT * FROM SYS.procedures;
SELECT * FROM SYS.syscomments;


-- DMV FOR VIEWING EXECUTION PLAN
SELECT C.USECOUNTS, C.CACHEOBJTYPE, C.OBJTYPE, T.TEXT, C.PLAN_HANDLE
FROM SYS.DM_EXEC_CACHED_PLANS C
CROSS APPLY SYS.dm_exec_sql_text(C.PLAN_HANDLE) T
WHERE T.TEXT LIKE '%EMPLOYEES%';

DBCC DROPCLEANBUFFERS; -- TO CLEAN BUFFER CACHE
DBCC FREEPROCCACHE; -- TO CLEAR PROCEDURE CACHE

-- PROCEDURE WHICH INSERTS DATA IN BANK TABLE USING VUSAVINGACCOUNT VIEW AND AFTER INSERTING DISPLAY ALL THE DETAILS FOR CUTSOMERS HAVING SAVINGS ACCOUNT
CREATE PROC INSERTBANKDETAILS @ID INT, @NAME VARCHAR(50), @TYPE VARCHAR(50), @BAL FLOAT
AS
BEGIN
	INSERT INTO VUSAVINGACCOUNT (CID,CNAME,ACCTYPE,BALANCE)
	VALUES (@ID, @NAME, @TYPE, @BAL);

	SELECT CID, CNAME, ACCTYPE, BALANCE
	FROM VUSAVINGACCOUNT;
END

EXEC INSERTBANKDETAILS @ID = 100, @NAME = 'VANSHIKA', @TYPE = 'SAVING', @BAL = 100000;

CREATE PROC USP_BANKTRANSACTION @ID INT, @NAME VARCHAR(50), @TYPE VARCHAR(50) = 'SAVING', @BAL FLOAT
AS
BEGIN
	INSERT INTO BANK (CID,CNAME,ACCTYPE,BALANCE)
	VALUES (@ID, @NAME, @TYPE, @BAL);

	SELECT *
	FROM VUSAVINGACCOUNT;
	SELECT *
	FROM VUCURRENTACCOUNT;
	SELECT *
	FROM VUJOINTACCOUNT;
END

EXEC USP_BANKTRANSACTION 15, 'ROSELINE', 'CURRENT', 765432;
EXEC USP_BANKTRANSACTION @ID = 60, @NAME = 'JACK', @BAL = 765432;

--  
CREATE PROC USP_EMPINFO @ID INT = NULL
AS
BEGIN
	IF @ID IS NULL
		SELECT * FROM EMPLOYEES;
	ELSE 
		SELECT * FROM EMPLOYEES
		WHERE EMPLOYEE_ID = @ID;
END;

EXEC USP_EMPINFO;
EXEC USP_EMPINFO 100;

-- 
CREATE PROC USP_EMPID @ID INT = NULL
AS
BEGIN
	DECLARE @MAXEID INT, @MINEID INT
	SELECT @MAXEID = MAX(EMPLOYEE_ID), @MINEID = MIN(EMPLOYEE_ID)
	FROM EMPLOYEES;

	IF @ID >= @MINEID AND @ID <= @MAXEID
		BEGIN
			IF EXISTS(
				SELECT * FROM EMPLOYEES 
				WHERE EMPLOYEE_ID = @ID
			)
			ELSE SELECT * FROM EMPLOYEES;
		END
	ELSE 
		SELECT * FROM EMPLOYEES;
END;

ALTER PROC USP_EMPID @ID INT = NULL
AS
BEGIN
		DECLARE @MAXEID INT, @MINEID INT
		SELECT @MAXEID = MAX(EMPLOYEE_ID), @MINEID = MIN(EMPLOYEE_ID)
		FROM EMPLOYEES;
			IF EXISTS(
				SELECT * FROM EMPLOYEES 
				WHERE EMPLOYEE_ID = @ID
			)
				SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID = @ID
			ELSE 
				SELECT * FROM EMPLOYEES;
END;

EXEC USP_EMPID 199;
EXEC USP_EMPID 103;

--SALES DEPT, NO. OF EMPLOYEES, TOTAL SAL, AVG SAL, HIGHEST VAL

CREATE PROC USP_DEPTWISEINFO @DEPT VARCHAR(50)
AS 
BEGIN
	DECLARE @DEPT_ID INT
	SELECT @DEPT_ID = DEPARTMENT_ID	FROM DEPARTMENTS WHERE DEPARTMENT_NAME = @DEPT;
	SELECT *  FROM EMPLOYEES 
	WHERE DEPARTMENT_ID = @DEPT_ID;
	SELECT COUNT(EMPLOYEE_ID) AS NO_OF_EMP, SUM(SALARY) AS TOTAL_SAL, 
		   AVG(SALARY) AS AVG_SAL, MAX(SALARY) AS MAX_SAL, MIN(SALARY) AS MIN_SAL
	FROM EMPLOYEES
	WHERE DEPARTMENT_ID = @DEPT_ID;
END

EXEC USP_DEPTWISEINFO 'SALES';

ALTER PROC USP_DEPTWISEINFO @DEPT VARCHAR(50)
AS 
BEGIN
	DECLARE @DEPT_ID INT
	SELECT @DEPT_ID = DEPARTMENT_ID	FROM DEPARTMENTS WHERE DEPARTMENT_NAME = @DEPT;
	SELECT @DEPT AS DEPT_NAME;
	SELECT *  FROM EMPLOYEES 
	WHERE DEPARTMENT_ID = @DEPT_ID;
	SELECT COUNT(EMPLOYEE_ID) AS NO_OF_EMP, SUM(SALARY) AS TOTAL_SAL, 
		   ISNULL(AVG(SALARY),0) AS AVG_SAL, MAX(SALARY) AS MAX_SAL, MIN(SALARY) AS MIN_SAL
	FROM EMPLOYEES
	WHERE DEPARTMENT_ID = @DEPT_ID;
END

-- SEARCH DETAILS OF EMPLOYEES USING THEIR LASTNAME
CREATE PROC SEARCH_EMP @ALPHA VARCHAR(20)
AS
BEGIN
	SELECT *
	FROM EMPLOYEES
	WHERE LAST_NAME LIKE '%' + @ALPHA +'%'
END;

EXEC SEARCH_EMP 'NG';

-- STATEMENT FOR 1997 HIRED EMPLOYED
CREATE PROC USP_EMPSTATEMENT @SD DATETIME, @ED DATETIME
AS
BEGIN
	SELECT *
	FROM EMPLOYEES 
	WHERE HIRE_DATE BETWEEN @SD AND @ED;
END;

EXEC USP_EMPSTATEMENT '1997-01-01', '1997-12-31';

--> PROCEDURE RETURNING VALUES USING OUTPUT PARAMETERS

CREATE PROCEDURE USP_DEPTEMP @DEPT_ID INT
AS
BEGIN
	SELECT SUM(SALARY), AVG(SALARY)
	FROM EMPLOYEES
	WHERE DEPARTMENT_ID = @DEPT_ID;
END;

ALTER PROCEDURE USP_DEPTEMP @DEPT_ID INT
AS
BEGIN
	SELECT SUM(SALARY) AS TOTAL_SAL, AVG(SALARY) AS AVG_SAL
	FROM EMPLOYEES
	WHERE DEPARTMENT_ID = @DEPT_ID;
END;

EXEC USP_DEPTEMP @DEPT_ID = 30;

ALTER PROCEDURE USP_DEPTEMP @DEPT_ID INT, @SUM INT OUTPUT, @AVG FLOAT OUT
AS
BEGIN
	SELECT @SUM = SUM(SALARY), @AVG = ISNULL(AVG(SALARY),0)
	FROM EMPLOYEES
	WHERE DEPARTMENT_ID = @DEPT_ID;
END;

--EXECUTING THIS: WE USE ANONYMOUS STORED PROCEDURE; WRITING BEGIN AND END IS NOT COMPULSORY HERE
BEGIN
DECLARE @S FLOAT, @A FLOAT
EXEC USP_DEPTEMP @DEPT_ID = 30, @SUM = @S OUTPUT, @AVG = @A OUT
SELECT @S AS TOTAL_SAL, @A AS AVG_SAL
END

-- SCOPE OF THE VARIABLES IS ONLY TILL THEIR STORED PROCEDURES
-- PROCEDURES PERFORM ACTION WHICH MAY OR MAY NOT RETURN ONE OR N NO. OF VALUES
-- WHILE FUNCTION IS A LOGIC THAT RETURNS ONE VALUE

CREATE PROC USP_EMPAVGDETAILS @DID INT 
AS
BEGIN
	SELECT * 
	FROM EMPLOYEES 
	WHERE SALARY > (SELECT AVG(SALARY) 
				    FROM EMPLOYEES 
					WHERE DEPARTMENT_ID = @DID)
END;

EXEC USP_EMPAVGDETAILS @DID = 30;

--CALLING ONE PROCEDURE INTO ANOTHER TO AVOID BOILER PLATE CODE(I.E. WRITING SAME CODE AGAIN AND AGAIN)

CREATE PROC USP_AVGDETAILS @ID INT 
AS
BEGIN
	DECLARE @S FLOAT , @A FLOAT
	EXEC USP_DEPTEMP @DEPT_ID = @ID, @SUM = @S OUT, @AVG = @A OUT
	SELECT @S AS TOTAL_SALARY, @A AS AVG_SALARY;
	SELECT * 
	FROM EMPLOYEES 
	WHERE SALARY > @A
END;

EXEC USP_AVGDETAILS @ID = 30;

							--------------> WINDOWS FUNCTIONS <---------------
-- RANK()
-- DENSE_RANK()
-- ROW_NUMBER()
-- NTILE()
-- STRING_AGG()

--> 1. STRING_AGG()
SELECT DEPARTMENT_NAME, 
	   STRING_AGG(LAST_NAME, ', ')
					  WITHIN GROUP (ORDER BY LAST_NAME ASC) AS EMPLOYEE_LIST, 
	   COUNT(EMPLOYEE_ID) AS EMP_COUNT
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

SELECT DEPARTMENT_NAME, 
	   STRING_AGG(LAST_NAME, ', ')
					  WITHIN GROUP (ORDER BY LAST_NAME ASC) AS EMPLOYEE_LIST, 
	   COUNT(EMPLOYEE_ID) AS EMP_COUNT
FROM DEPARTMENTS D INNER JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME;

SELECT DEPARTMENT_NAME, 
	   STRING_AGG(LAST_NAME, ', ')
					  WITHIN GROUP (ORDER BY LAST_NAME ASC) AS EMPLOYEE_LIST, 
	   COUNT(EMPLOYEE_ID) AS EMP_COUNT
FROM DEPARTMENTS D RIGHT JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME;

--> 2. RANK(): IT SKIPS THE VALUE
SELECT DEPARTMENT_ID, EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, HIRE_DATE,
	   RANK() OVER (ORDER BY SALARY DESC) AS [RANK]
FROM EMPLOYEES;

--> 3. DENSE_RANK(): IT DOES NOT SKIP THE VALUES
SELECT DEPARTMENT_ID, EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, HIRE_DATE,
	   DENSE_RANK() OVER (ORDER BY SALARY DESC) AS [DENSE_RANK]
FROM EMPLOYEES;

--> 4. ROW_NUMBER()
SELECT DEPARTMENT_ID, EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, HIRE_DATE,
	   ROW_NUMBER() OVER (ORDER BY SALARY DESC) AS [ROW_NUMBER]
FROM EMPLOYEES;

--> 5. NTILE()
SELECT DEPARTMENT_ID, EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, HIRE_DATE,
	   NTILE(5) OVER (ORDER BY SALARY DESC) AS [NTILE]
FROM EMPLOYEES;

--
SELECT DEPARTMENT_ID, EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, HIRE_DATE,
	   RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) AS [RANK]
FROM EMPLOYEES;

SELECT DEPARTMENT_ID, EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, HIRE_DATE,
	  RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC)AS RANK , 
	  DENSE_RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) AS DENSE_RANK
FROM EMPLOYEES;

--
SELECT DEPARTMENT_ID, EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, HIRE_DATE,
	   RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) AS [RANK]
FROM EMPLOYEES
WHERE RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) = 1; ---ERROR

--DERIVED TABLE :- QUERY IN A FROM CLAUSE

SELECT * 
FROM (SELECT DEPARTMENT_ID, EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, HIRE_DATE, 
	  RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) AS [EMP_RANK]
	  FROM EMPLOYEES) INFO
WHERE EMP_RANK = 1;

-- SECOND HIGHEST SALARY

SELECT * 
FROM (SELECT DEPARTMENT_ID, EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, HIRE_DATE, 
	  DENSE_RANK() OVER (ORDER BY SALARY DESC) AS [EMP_RANK]
	  FROM EMPLOYEES) INFO
WHERE EMP_RANK = 2;
-- INFO TABLE IS IN MEMORY WHICH GETS DESTROYED WHEN ITS WORK IS DONE

-- SECOND WAY
-- CTE - COMMON TABLE EXPRESSION
WITH INFO
AS(
	SELECT DEPARTMENT_ID, EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, HIRE_DATE,
		   RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) AS [RANK]
	FROM EMPLOYEES
)

SELECT * FROM INFO WHERE RANK = 1
SELECT * FROM INFO WHERE RANK = 2
-- THE SCOPE OF CTE IS ONLY TILL THE FIRST QUERY AFTER THE CTE; SO IT SHOWS ERROR HERE FOR RANK = 2

-- TEMPORARY TABLE
-- Is created in tempdb
-- Table name is prefixed with # symbol
-- Scope of temp table is throughout the session

SELECT DEPARTMENT_ID, EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, HIRE_DATE,
		   RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) AS [RANK]
INTO #INFO_3686 -- # DENOTES TEMPORARY TABLE	
FROM EMPLOYEES

SELECT * FROM #INFO_3686;

SELECT * FROM #INFO_3686 where	rank = 1;
SELECT * FROM #INFO_3686 where	rank = 2;

drop table #INFO_3686;

-- global temp table
-- Is created in tempdb
-- Table name is prefixed with ## symbol
-- Scope of temp table is till all the sessions

SELECT DEPARTMENT_ID, EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, HIRE_DATE,
		   RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) AS [RANK]
INTO ##INFO_3686 -- ## DENOTES global TEMPORARY TABLE	
FROM EMPLOYEES

drop table ##INFO_3686;

-- temp tables are not a good practice; rather table variables (advanced sql topic) are used

--
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, JOB_ID, DEPARTMENT_ID,
	   COUNT(EMPLOYEE_ID) OVER (PARTITION BY DEPARTMENT_ID) AS EMP_COUNT, 
	   SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID) AS TOTAL_SAL,
	   ROUND(AVG(ISNULL(SALARY,0)) OVER (PARTITION BY DEPARTMENT_ID),2) AS AVG_SAL
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (30,60,90);

-- FOR DATA ALONG WITH AGGREGATION, WE SHOULD USE OVER WITH PARTITION BY






